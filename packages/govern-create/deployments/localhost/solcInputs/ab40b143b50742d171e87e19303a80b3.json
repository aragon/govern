{
  "language": "Solidity",
  "sources": {
    "contracts/core-factories/GovernFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"erc3k/contracts/IERC3000.sol\";\nimport \"@aragon/govern-core/contracts/Govern.sol\";\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\nimport \"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\";\n\ncontract GovernFactory {\n    using ERC1167ProxyFactory for address;\n    using AddressUtils for address;\n    \n    address public base;\n\n    constructor() public {\n        setupBase();\n    }\n\n    function newGovern(IERC3000 _initialExecutor, bytes32 _salt) public returns (Govern govern) {\n        if (_salt != bytes32(0)) {\n            return Govern(base.clone2(_salt, abi.encodeWithSelector(govern.initialize.selector, _initialExecutor)).toPayable());\n        } else {\n            return new Govern(address(_initialExecutor));\n        }\n    }\n\n    function setupBase() private {\n        base = address(new Govern(address(2)));\n    }\n}\n"
    },
    "erc3k/contracts/IERC3000.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\n\ncontract ERC3000Interface {\n    bytes4 internal constant ERC3000_INTERFACE_ID =\n        IERC3000(0).schedule.selector\n        ^ IERC3000(0).execute.selector\n        ^ IERC3000(0).challenge.selector\n        ^ IERC3000(0).resolve.selector\n        ^ IERC3000(0).veto.selector\n        ^ IERC3000(0).configure.selector\n    ;\n}\n\nabstract contract IERC3000 is ERC3000Interface {\n    /**\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\n     * @param container A Container struct holding both the payload being scheduled for execution and\n       the current configuration of the system\n     * @return containerHash\n     */\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\n\n    /**\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\n     * @param container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\n       the current configuration of the system\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\n     * @return failureMap\n     * @return execResults\n     */\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Executed(bytes32 indexed containerHash, address indexed actor);\n\n    /**\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n       the current configuration of the system\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\n     * @return resolverId\n     */\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\n       the current configuration of the system\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\n     * @return failureMap\n     * @return execResults\n     */\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param containerHash Hash of the container being vetoed\n     * @param reason Justification for the veto\n     */\n    function veto(bytes32 containerHash, bytes memory reason) virtual public;\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\n\n    /**\n     * @notice Apply a new configuration for all *new* containers to be scheduled\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\n     * @return configHash\n     */\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\n    event Configured(bytes32 indexed containerHash, address indexed actor, ERC3000Data.Config config);\n}\n"
    },
    "@aragon/govern-core/contracts/Govern.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"erc3k/contracts/IERC3000Executor.sol\";\nimport \"erc3k/contracts/IERC3000.sol\";\n\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\";\nimport \"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\";\n\ncontract Govern is AdaptativeERC165, IERC3000Executor, ACL {\n    using BitmapLib for bytes32;\n\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\n    bytes4 internal constant REGISTER_ROLE = this.registerStandardAndCallback.selector;\n    uint256 internal constant MAX_ACTIONS = 256;\n\n    event ETHDeposited(address indexed sender, uint256 value);\n\n    constructor(address _initialExecutor) ACL(address(this)) public {\n        initialize(_initialExecutor);\n    }\n\n    function initialize(address _initialExecutor) public initACL(_initialExecutor) onlyInit(\"govern\") {\n        _grant(EXEC_ROLE, address(_initialExecutor));\n        _grant(REGISTER_ROLE, address(_initialExecutor));\n        _registerStandard(ERC3000_EXEC_INTERFACE_ID);\n    }\n\n    receive () external payable {\n        emit ETHDeposited(msg.sender, msg.value);\n    }\n\n    fallback () external {\n        _handleCallback(msg.sig, msg.data); // WARN: does a low-level return, any code below would be unreacheable\n    }\n\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) override public auth(EXEC_ROLE) returns (bytes32, bytes[] memory) {\n        require(actions.length <= MAX_ACTIONS, \"govern: too many\"); // need to limit since we use 256-bit bitmaps\n        \n        bytes[] memory execResults = new bytes[](actions.length);\n        bytes32 failureMap = BitmapLib.empty; // start with an empty bitmap\n\n        for (uint256 i = 0; i < actions.length; i++) { // can use uint8 given the action limit\n            // TODO: optimize with assembly\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\n            require(ok || allowFailuresMap.get(uint8(i)), \"govern: call\");\n            // if a call fails, flip that bit to signal failure\n            failureMap = ok ? failureMap : failureMap.flip(uint8(i));\n            execResults[i] = ret;\n        }\n\n        emit Executed(msg.sender, actions, memo, failureMap, execResults);\n\n        return (failureMap, execResults);\n    }\n\n    function registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) external auth(REGISTER_ROLE) {\n        _registerStandardAndCallback(_interfaceId, _callbackSig, _magicNumber);\n    }\n\n    // TODO: ERC-1271\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// Inspired by: https://github.com/optionality/clone-factory\n\npragma solidity ^0.6.8;\n\nlibrary ERC1167ProxyFactory {\n    function clone(address _implementation) internal returns (address cloneAddr) {\n        bytes memory code = generateCode(_implementation);\n\n        assembly {\n            cloneAddr := create(0, add(code, 0x20), 55)\n        }\n        \n        require(cloneAddr != address(0), \"proxy-factory: bad create\");\n    }\n\n    function clone(address _implementation, bytes memory _initData) internal returns (address cloneAddr) {\n        cloneAddr = clone(_implementation);\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\n\n        require(ok, _getRevertMsg(ret));\n    }\n\n    function clone2(address _implementation, bytes32 _salt) internal returns (address cloneAddr) {\n        bytes memory code = generateCode(_implementation);\n        \n        assembly {\n            cloneAddr := create2(0, add(code, 0x20), 55, _salt)\n        }\n        \n        require(cloneAddr != address(0), \"proxy-factory: bad create2\");\n    }\n\n    function clone2(address _implementation, bytes32 _salt, bytes memory _initData) internal returns (address cloneAddr) {\n        cloneAddr = clone2(_implementation, _salt);\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\n\n        require(ok, _getRevertMsg(ret));\n    }\n\n    function generateCode(address _implementation) internal pure returns (bytes memory code) {\n        code = new bytes(55);\n        \n        assembly {\n            mstore(add(code, 0x20), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(code, 0x34), shl(0x60, _implementation))\n            mstore(add(code, 0x48), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n        }\n    }\n\n    // From: https://ethereum.stackexchange.com/a/83577\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return '';\n\n        assembly {\n            _returnData := add(_returnData, 0x04) // Slice the sighash.\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nlibrary AddressUtils {\n    function toPayable(address addr) internal pure returns (address payable) {\n        return address(bytes20(addr));\n    }\n\n    function toAddress(address addr) internal pure returns (address payable) {\n        return address(bytes20(addr));\n    }\n\n    function isContract(address addr) internal view returns (bool result) {\n        assembly {\n            result := not(iszero(extcodesize(addr)))\n        }\n    }\n}"
    },
    "erc3k/contracts/ERC3000Data.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC3000Executor.sol\";\n\nlibrary ERC3000Data {\n    // TODO: come up with a non-shitty name\n    struct Container {\n        Payload payload;\n        Config config;\n    }\n\n    // WARN: Always remember to change the 'hash' function if modifying the struct\n    struct Payload {\n        uint256 nonce;\n        uint256 executionTime;\n        address submitter;\n        IERC3000Executor executor;\n        Action[] actions;\n        bytes32 allowFailuresMap;\n        bytes proof;\n    }\n\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    struct Config {\n        uint256 executionDelay;\n        Collateral scheduleDeposit;\n        Collateral challengeDeposit;\n        address resolver;\n        bytes rules;\n    }\n\n    struct Collateral {\n        address token;\n        uint256 amount;\n    }\n\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        return keccak256(abi.encodePacked(\"erc3k-v1\", address(this), chainId, payloadHash, configHash));\n    }\n\n    function hash(Container memory container) internal view returns (bytes32) {\n        return containerHash(hash(container.payload), hash(container.config));\n    }\n\n    function hash(Payload memory payload) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                payload.nonce,\n                payload.executionTime,\n                payload.submitter,\n                payload.executor,\n                keccak256(abi.encode(payload.actions)),\n                payload.allowFailuresMap,\n                keccak256(payload.proof)\n            )\n        );\n    }\n\n    function hash(Config memory config) internal pure returns (bytes32) {\n        return keccak256(abi.encode(config));\n    }\n}\n"
    },
    "erc3k/contracts/IERC3000Executor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC3000Data.sol\";\n\nabstract contract IERC3000Executor {\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\n\n    /**\n     * @notice Executes all given actions\n     * @param actions A array of ERC3000Data.Action for later executing those\n     * @param allowFailuresMap A map with the allowed failures\n     * @param memo The hash of the ERC3000Data.Container\n     * @return failureMap\n     * @return execResults\n     */\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/acl/ACL.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"../initializable/Initializable.sol\";\n\nimport \"./IACLOracle.sol\";\n\nlibrary ACLData {\n    enum BulkOp { Grant, Revoke, Freeze }\n\n    struct BulkItem {\n        BulkOp op;\n        bytes4 role;\n        address who;\n    }\n}\n\ncontract ACL is Initializable {\n    bytes4 public constant ROOT_ROLE =\n        this.grant.selector\n        ^ this.revoke.selector\n        ^ this.freeze.selector\n        ^ this.bulk.selector\n    ;\n\n    address internal constant FREEZE_FLAG = address(1);\n    address internal constant ANY_ADDR = address(-1);\n\n    address internal constant UNSET_ROLE = address(0);\n    address internal constant ALLOW_FLAG = address(2);\n    \n    mapping (bytes4 => mapping (address => address)) public roles;\n\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\n    event Frozen(bytes4 indexed role, address indexed actor);\n\n    modifier auth(bytes4 _role) {\n        require(willPerform(_role, msg.sender, msg.data), \"acl: auth\");\n        _;\n    }\n\n    modifier initACL(address _initialRoot) {\n        // ACL might have been already initialized by constructors\n        if (initBlocks[\"acl\"] == 0) {\n            _initializeACL(_initialRoot);\n        }\n        _;\n    }\n\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\n\n    function _initializeACL(address _initialRoot) internal onlyInit(\"acl\") {\n        _grant(ROOT_ROLE, _initialRoot);\n    }\n\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _grant(_role, _who);\n    }\n\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\n        _grantWithOracle(_role, _who, _oracle);\n    }\n\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\n        _revoke(_role, _who);\n    }\n\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\n        _freeze(_role);\n    }\n\n    function bulk(ACLData.BulkItem[] memory items) public auth(ROOT_ROLE) {\n        for (uint256 i = 0; i < items.length; i++) {\n            ACLData.BulkItem memory item = items[i];\n\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\n        }\n    }\n\n    function willPerform(bytes4 _role, address _sender, bytes memory _data) public returns (bool) {\n        address senderRole = roles[_role][msg.sender];\n        if (senderRole != UNSET_ROLE) {\n            if (senderRole == ALLOW_FLAG) return true;\n            if (IACLOracle(senderRole).willPerform(_role, _sender, _data)) return true;\n        }\n\n        address anyRole = roles[_role][ANY_ADDR];\n        if (anyRole != UNSET_ROLE) {\n            if (anyRole == ALLOW_FLAG) return true;\n            if (IACLOracle(anyRole).willPerform(_role, _sender, _data)) return true;\n        }\n\n        return false;\n    }\n\n    function _grant(bytes4 _role, address _who) internal {\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\n    }\n\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n        require(_who != FREEZE_FLAG, \"acl: bad freeze\");\n        \n        roles[_role][_who] = address(_oracle);\n        emit Granted(_role, msg.sender, _who, _oracle);\n    }\n\n    function _revoke(bytes4 _role, address _who) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][_who] = UNSET_ROLE;\n        emit Revoked(_role, msg.sender, _who);\n    }\n\n    function _freeze(bytes4 _role) internal {\n        require(!isFrozen(_role), \"acl: frozen\");\n\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\n\n        emit Frozen(_role, msg.sender);\n    }\n\n    function isFrozen(bytes4 _role) public view returns (bool) {\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\n    }\n}"
    },
    "@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nimport \"../erc165/ERC165.sol\";\n\ncontract AdaptativeERC165 is ERC165 {\n    // erc165 interface ID -> whether it is supported\n    mapping (bytes4 => bool) internal standardSupported;\n    // callback function signature -> magic number to return\n    mapping (bytes4 => bytes32) internal callbackMagicNumbers;\n\n    bytes32 internal constant UNREGISTERED_CALLBACK = bytes32(0);\n\n    event RegisteredStandard(bytes4 interfaceId);\n    event RegisteredCallback(bytes4 sig, bytes4 magicNumber);\n    event ReceivedCallback(bytes4 indexed sig, bytes data);\n\n    function supportsInterface(bytes4 _interfaceId) override virtual public view returns (bool) {\n        return standardSupported[_interfaceId] || super.supportsInterface(_interfaceId);\n    }\n\n    function _handleCallback(bytes4 _sig, bytes memory _data) internal {\n        bytes32 magicNumber = callbackMagicNumbers[_sig];\n        require(magicNumber != UNREGISTERED_CALLBACK, \"adap-erc165: unknown callback\");\n\n        emit ReceivedCallback(_sig, _data);\n\n        // low-level return magic number\n        assembly {\n            mstore(0x00, magicNumber)\n            return(0x00, 0x20)\n        }\n    }\n\n    function _registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) internal {\n        _registerStandard(_interfaceId);\n        _registerCallback(_callbackSig, _magicNumber);\n    }\n\n    function _registerStandard(bytes4 _interfaceId) internal {\n        // use a random magic number for standards without number\n        standardSupported[_interfaceId] = true;\n\n        emit RegisteredStandard(_interfaceId);\n    }\n\n    function _registerCallback(bytes4 _callbackSig, bytes4 _magicNumber) internal {\n        callbackMagicNumbers[_callbackSig] = _magicNumber;\n\n        emit RegisteredCallback(_callbackSig, _magicNumber);\n    }\n}"
    },
    "@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nlibrary BitmapLib {\n    bytes32 constant internal empty = bytes32(0);\n    bytes32 constant internal allowAll = empty;\n    bytes32 constant internal denyAll = bytes32(uint256(-1));\n\n    function flip(bytes32 map, uint8 index) internal pure returns (bytes32) {\n        return bytes32(uint256(map) ^ uint256(1) << index);\n    }\n\n    function get(bytes32 map, uint8 index) internal pure returns (bool) {\n        return bool(uint256(map) >> index & 1 == 1);\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/initializable/Initializable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.6.8;\n\ncontract Initializable {\n    mapping (string => uint256) public initBlocks;\n\n    event Initialized(string indexed key);\n\n    modifier onlyInit(string memory key) {\n        require(initBlocks[key] == 0, \"initializable: already initialized\");\n        initBlocks[key] = block.number;\n        _;\n        emit Initialized(key);\n    }\n}"
    },
    "@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity 0.6.8;\n\ninterface IACLOracle {\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\n}"
    },
    "@aragon/govern-contract-utils/contracts/erc165/ERC165.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.6.8;\n\nabstract contract ERC165 {\n    // Includes supportsInterface method:\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\n\n    /**\n    * @dev Query if a contract implements a certain interface\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\n    */\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\n        return _interfaceId == ERC165_INTERFACE_ID\n          || block.timestamp == 1; // silence visibility warning needed for overrides\n    }\n}"
    },
    "contracts/GovernBaseFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-core/contracts/GovernRegistry.sol\";\n\nimport \"@aragon/govern-token/contracts/GovernTokenFactory.sol\";\nimport \"@aragon/govern-token/contracts/interfaces/IERC20.sol\";\n\nimport \"./core-factories/GovernFactory.sol\";\nimport \"./core-factories/GovernQueueFactory.sol\";\n\ncontract GovernBaseFactory {\n    address internal constant ANY_ADDR = address(-1);\n\n    GovernFactory public governFactory;\n    GovernQueueFactory public queueFactory;\n    GovernTokenFactory public tokenFactory;\n    GovernRegistry public registry;\n\n    constructor(\n        GovernRegistry _registry,\n        GovernFactory _governFactory,\n        GovernQueueFactory _queueFactory,\n        GovernTokenFactory _tokenFactory\n    ) public {\n        governFactory = _governFactory;\n        queueFactory = _queueFactory;\n        tokenFactory = _tokenFactory;\n        registry = _registry;\n    }\n\n    function newGovernWithoutConfig(\n        string calldata _name,\n        IERC20 _token,\n        string calldata _tokenName,\n        string calldata _tokenSymbol,\n        bool _useProxies\n    ) external returns (Govern govern, GovernQueue queue) {\n        bytes32 salt = _useProxies ? keccak256(abi.encodePacked(_name)) : bytes32(0);\n\n        queue = queueFactory.newQueue(address(this), dummyConfig(), salt);\n        govern = governFactory.newGovern(queue, salt);\n\n        if (address(_token) == address(0)) {\n            (_token,) = tokenFactory.newToken(\n                address(this),\n                _tokenName,\n                _tokenSymbol,\n                18, // NOTE: hardcoding due to stack to deep issues\n                msg.sender,\n                1 * 10 ** 18,\n                _useProxies\n            );\n        }\n\n        registry.register(govern, queue, _token, _name, \"\");\n\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](6);\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.schedule.selector, ANY_ADDR);\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.execute.selector, ANY_ADDR);\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.challenge.selector, ANY_ADDR);\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Grant, queue.configure.selector, address(govern));\n        items[4] = ACLData.BulkItem(ACLData.BulkOp.Revoke, queue.ROOT_ROLE(), address(this));\n        items[5] = ACLData.BulkItem(ACLData.BulkOp.Freeze, queue.ROOT_ROLE(), address(0));\n        \n        queue.bulk(items);\n    }\n\n    function dummyConfig() internal pure returns (ERC3000Data.Config memory) {\n        ERC3000Data.Collateral memory noCollateral;\n        return ERC3000Data.Config(\n            0,\n            noCollateral,\n            noCollateral,\n            address(0),\n            \"\"\n        );\n    }\n}\n"
    },
    "@aragon/govern-core/contracts/GovernRegistry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"erc3k/contracts/IERC3000.sol\";\nimport \"erc3k/contracts/IERC3000Executor.sol\";\nimport \"erc3k/contracts/IERC3000Registry.sol\";\n\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\n\ncontract GovernRegistry is IERC3000Registry {\n    mapping(string => bool) public nameUsed;\n\n    function register(\n        IERC3000Executor _executor,\n        IERC3000 _queue,\n        IERC20 _token,\n        string calldata _name,\n        bytes calldata _initialMetadata\n    ) override external\n    {\n        require(!nameUsed[_name], \"registry: name used\");\n\n        nameUsed[_name] = true;\n\n        emit Registered(_executor, _queue, _token, msg.sender, _name);\n        _setMetadata(_executor, _initialMetadata);\n    }\n\n    function setMetadata(bytes memory _metadata) override public {\n        _setMetadata(IERC3000Executor(msg.sender), _metadata);\n    }\n\n    function _setMetadata(IERC3000Executor _executor, bytes memory _metadata) internal {\n        emit SetMetadata(_executor, _metadata);\n    }\n}\n"
    },
    "@aragon/govern-token/contracts/GovernTokenFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\n\nimport \"./GovernToken.sol\";\nimport \"./GovernMinter.sol\";\nimport \"./MerkleDistributor.sol\";\n\ncontract GovernTokenFactory {\n    using ERC1167ProxyFactory for address;\n    \n    address public tokenBase;\n    address public minterBase;\n    address public distributorBase;\n\n    event CreatedToken(GovernToken token, GovernMinter minter);\n\n    constructor() public {\n        setupBases();\n    }\n\n    function newToken(\n        address _initialMinter,\n        string calldata _tokenName,\n        string calldata _tokenSymbol,\n        uint8 _tokenDecimals,\n        address _mintAddr,\n        uint256 _mintAmount,\n        bool _useProxies\n    ) external returns (\n        GovernToken token,\n        GovernMinter minter\n    ) {\n        if (!_useProxies) {\n            (token, minter) = _deployContracts(_initialMinter, _tokenName, _tokenSymbol, _tokenDecimals);\n        } else {\n            token = GovernToken(tokenBase.clone(abi.encodeWithSelector(\n                token.initialize.selector,\n                address(this),\n                _tokenName,\n                _tokenSymbol,\n                _tokenDecimals\n            ))); \n            minter = GovernMinter(minterBase.clone(abi.encodeWithSelector(\n                minter.initialize.selector,\n                token,\n                address(this),\n                MerkleDistributor(distributorBase)\n            )));\n        }\n\n        token.changeMinter(address(minter));\n        if (_mintAmount > 0) minter.mint(_mintAddr, _mintAmount, \"initial mint\");\n\n        bytes4 mintRole = minter.mint.selector ^ minter.merkleMint.selector;\n        bytes4 rootRole = minter.ROOT_ROLE();\n\n        ACLData.BulkItem[] memory items = new ACLData.BulkItem[](4);\n\n        items[0] = ACLData.BulkItem(ACLData.BulkOp.Grant, mintRole, _initialMinter);\n        items[1] = ACLData.BulkItem(ACLData.BulkOp.Grant, rootRole, _initialMinter);\n        items[2] = ACLData.BulkItem(ACLData.BulkOp.Revoke, mintRole, address(this));\n        items[3] = ACLData.BulkItem(ACLData.BulkOp.Revoke, rootRole, address(this));\n\n        minter.bulk(items);\n\n        emit CreatedToken(token, minter);\n    }\n\n    function setupBases() private {\n        distributorBase = address(new MerkleDistributor(ERC20(tokenBase), bytes32(0)));\n        \n        (GovernToken token, GovernMinter minter) = _deployContracts(\n            address(this),\n            \"GovernToken base\",\n            \"GTB\",\n            0\n        );\n        token.changeMinter(address(minter));\n\n        // test the bases\n        minter.mint(msg.sender, 1, \"test mint\");\n        minter.merkleMint(bytes32(0), 1, \"no tree\", \"test merkle mint\");\n\n        // store bases\n        tokenBase = address(token);\n        minterBase = address(minter);\n    }\n\n    function _deployContracts(\n        address _initialMinter,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        uint8 _tokenDecimals\n    ) internal returns (\n        GovernToken token,\n        GovernMinter minter\n    ) {\n        token = new GovernToken(address(this), _tokenName, _tokenSymbol, _tokenDecimals);\n        minter = new GovernMinter(GovernToken(token), address(_initialMinter), MerkleDistributor(distributorBase));\n    }\n}\n"
    },
    "@aragon/govern-token/contracts/interfaces/IERC20.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/core-factories/GovernQueueFactory.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-core/contracts/pipelines/GovernQueue.sol\";\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\n\ncontract GovernQueueFactory {\n    using ERC1167ProxyFactory for address;\n\n    address public base;\n\n    constructor() public {\n        setupBase();\n    }\n\n    function newQueue(address _aclRoot, ERC3000Data.Config memory _config, bytes32 _salt) public returns (GovernQueue queue) {\n        if (_salt != bytes32(0)) {\n            return GovernQueue(base.clone2(_salt, abi.encodeWithSelector(queue.initialize.selector, _aclRoot, _config)));\n        } else {\n            return new GovernQueue(_aclRoot, _config);\n        }\n    }\n\n    function setupBase() private {\n        ERC3000Data.Collateral memory noCollateral;\n        ERC3000Data.Config memory config = ERC3000Data.Config(\n            0,\n            noCollateral,\n            noCollateral,\n            address(0),\n            \"\"\n        );\n        base = address(new GovernQueue(address(2), config));\n    }\n}\n"
    },
    "erc3k/contracts/IERC3000Registry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"./IERC3000.sol\";\nimport \"./IERC3000Executor.sol\";\n\nimport \"@aragon/govern-token/contracts/interfaces/IERC20.sol\";\n\nabstract contract IERC3000Registry is ERC3000Interface {\n    /**\n     * @notice Registers a IERC3000Executor and IERC3000 contract by a name and with his metadata\n     * @param executor IERC3000Executor contract\n     * @param queue IERC3000 contract\n     * @param name The name of this DAO\n     * @param token Governance token of the DAO\n     * @param initialMetadata Additional data to store for this DAO\n     */\n    function register(IERC3000Executor executor, IERC3000 queue, IERC20 token, string calldata name, bytes calldata initialMetadata) virtual external;\n    event Registered(IERC3000Executor indexed executor, IERC3000 queue, IERC20 indexed token, address indexed registrant, string name);\n\n    /**\n     * @notice Sets or updates the metadata of a DAO\n     * @param metadata Additional data to store for this DAO\n     */\n    function setMetadata(bytes memory metadata) virtual public;\n    event SetMetadata(IERC3000Executor indexed executor, bytes metadata);\n}\n"
    },
    "@aragon/govern-token/contracts/GovernToken.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\n\nimport \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\";\n\nimport './interfaces/IERC20.sol';\nimport './libraries/SafeMath.sol';\n\n// Copied and slightly modified from https://github.com/aragon/aragon-network-token/blob/v2-v1.0.0/packages/v2/contracts/token.sol\n// Lightweight token modelled after UNI-LP: https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\n// Adds:\n//   - An exposed `mint()` with minting role\n//   - An exposed `burn()`\n//   - ERC-3009 (`transferWithAuthorization()`)\ncontract GovernToken is IERC20, Initializable {\n    using SafeMath for uint256;\n\n    // bytes32 private constant EIP712DOMAIN_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    // bytes32 private constant VERSION_HASH = keccak256(\"1\")\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    //     keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    address public minter;\n    uint256 override public totalSupply;\n    mapping (address => uint256) override public balanceOf;\n    mapping (address => mapping (address => uint256)) override public allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping (address => uint256) public nonces;\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event ChangeMinter(address indexed minter);\n\n    modifier onlyMinter {\n        require(msg.sender == minter, \"token: not minter\");\n        _;\n    }\n\n    constructor(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public {\n        initialize(_initialMinter, _name, _symbol, _decimals);\n    }\n\n    function initialize(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public onlyInit(\"token\") {\n        _changeMinter(_initialMinter);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                getDomainSeparator(),\n                encodeData\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"token: bad sig\");\n    }\n\n    function _changeMinter(address newMinter) internal {\n        minter = newMinter;\n        emit ChangeMinter(newMinter);\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint256 value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint256 value) private {\n        require(to != address(this) && to != address(0), \"token: bad to\");\n\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function getChainId() public pure returns (uint256 chainId) {\n        assembly { chainId := chainid() }\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_HASH,\n                keccak256(abi.encodePacked(name)),\n                VERSION_HASH,\n                getChainId(),\n                address(this)\n            )\n        );\n    }\n\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n\n    function changeMinter(address newMinter) external onlyMinter {\n        _changeMinter(newMinter);\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) override external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) override external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) override external returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != uint256(-1)) {\n            // Allowance is implicitly checked with SafeMath's underflow protection\n            allowance[from][msg.sender] = fromAllowance.sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, \"token: auth expired\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        require(block.timestamp > validAfter, \"token: auth wait\");\n        require(block.timestamp < validBefore, \"token: auth expired\");\n        require(!authorizationState[from][nonce],  \"token: auth used\");\n\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}\n"
    },
    "@aragon/govern-token/contracts/GovernMinter.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\npragma experimental ABIEncoderV2;\n\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\";\n\nimport \"./GovernToken.sol\";\nimport \"./MerkleDistributor.sol\";\n\ncontract GovernMinter is ACL {\n    using ERC1167ProxyFactory for address;\n\n    bytes4 constant internal MINT_ROLE =\n        this.mint.selector ^\n        this.merkleMint.selector\n    ;\n\n    GovernToken public token;\n    address public distributorBase;\n\n    event MintedSingle(address indexed to, uint256 amount, bytes context);\n    event MintedMerkle(address indexed distributor, bytes32 indexed merkleRoot, uint256 totalAmount, bytes tree, bytes context);\n\n    constructor(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) ACL(_initialMinter) public {\n        initialize(_token, _initialMinter, _distributorBase);\n    }\n\n    function initialize(GovernToken _token, address _initialMinter, MerkleDistributor _distributorBase) public initACL(_initialMinter) onlyInit(\"minter\") {\n        token = _token;\n        distributorBase = address(_distributorBase);\n        _grant(MINT_ROLE, _initialMinter);\n    }\n\n    function mint(address _to, uint256 _amount, bytes calldata _context) external auth(MINT_ROLE) {\n        token.mint(_to, _amount);\n        emit MintedSingle(_to, _amount, _context);\n    }\n\n    function merkleMint(bytes32 _merkleRoot, uint256 _totalAmount, bytes calldata _tree, bytes calldata _context) external auth(MINT_ROLE) returns (MerkleDistributor distributor) {\n        address distributorAddr = distributorBase.clone(abi.encodeWithSelector(distributor.initialize.selector, token, _merkleRoot));\n        token.mint(distributorAddr, _totalAmount);\n\n        emit MintedMerkle(distributorAddr, _merkleRoot, _totalAmount, _tree, _context);\n\n        return MerkleDistributor(distributorAddr);\n    }\n\n    function eject(address _newMinter) external auth(this.eject.selector) {\n        token.changeMinter(_newMinter);\n    }\n}\n"
    },
    "@aragon/govern-token/contracts/MerkleDistributor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\n// Copied and modified from: https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol\n\npragma solidity ^0.6.8;\n\nimport \"@openzeppelin/contracts/cryptography/MerkleProof.sol\";\n\nimport \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\";\nimport \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\";\n\ncontract MerkleDistributor is Initializable {\n    using SafeERC20 for ERC20;\n\n    ERC20 public token;\n    bytes32 public merkleRoot;\n\n    // This is a packed array of booleans.\n    mapping (uint256 => uint256) private claimedBitMap;\n\n    event Claimed(uint256 indexed index, address indexed to, uint256 amount);\n\n    constructor(ERC20 _token, bytes32 _merkleRoot) public {\n        initialize(_token, _merkleRoot);\n    }\n\n    function initialize(ERC20 _token, bytes32 _merkleRoot) public onlyInit(\"distributor\") {\n        token = _token;\n        merkleRoot = _merkleRoot;\n    }\n\n    function claim(uint256 _index, address _to, uint256 _amount, bytes32[] calldata _merkleProof) external {\n        require(!isClaimed(_index), \"dist: already claimed\");\n        require(_verifyBalanceOnTree(_index, _to, _amount, _merkleProof), \"dist: proof failed\");\n\n        _setClaimed(_index);\n        token.safeTransfer(_to, _amount);\n\n        emit Claimed(_index, _to, _amount);\n    }\n\n    function unclaimedBalance(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) public view returns (uint256) {\n        if (isClaimed(_index)) return 0;\n        return _verifyBalanceOnTree(_index, _to, _amount, _proof) ? _amount : 0;\n    }\n\n    function _verifyBalanceOnTree(uint256 _index, address _to, uint256 _amount, bytes32[] memory _proof) internal view returns (bool) {\n        bytes32 node = keccak256(abi.encodePacked(_index, _to, _amount));\n        return !MerkleProof.verify(_proof, merkleRoot, node);\n    }\n\n    function isClaimed(uint256 _index) public view returns (bool) {\n        uint256 claimedWord_index = _index / 256;\n        uint256 claimedBit_index = _index % 256;\n        uint256 claimedWord = claimedBitMap[claimedWord_index];\n        uint256 mask = (1 << claimedBit_index);\n        return claimedWord & mask == mask;\n    }\n\n    function _setClaimed(uint256 _index) private {\n        uint256 claimedWord_index = _index / 256;\n        uint256 claimedBit_index = _index % 256;\n        claimedBitMap[claimedWord_index] = claimedBitMap[claimedWord_index] | (1 << claimedBit_index);\n    }\n}"
    },
    "@aragon/govern-token/contracts/libraries/SafeMath.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity ^0.6.8;\n\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\n// Modified to include only the essentials\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"math: overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"math: underflow\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev These functions deal with verification of Merkle trees (hash trees),\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        // Check if the computed hash (root) is equal to the provided root\n        return computedHash == root;\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\n\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n\npragma solidity ^0.6.8;\n\nimport \"../address-utils/AddressUtils.sol\";\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\nabstract contract ERC20 {\n    function totalSupply() virtual public view returns (uint256);\n\n    function balanceOf(address _who) virtual public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        virtual public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) virtual public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        virtual public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        virtual public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeERC20 {\n    using AddressUtils for address;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool ret)\n    {\n        if (!_addr.isContract()) {\n            return false;\n        }\n\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas(),                // forward all \n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize()\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            _token.transfer.selector,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(address(_token), approveCallData);\n    }\n}"
    },
    "@aragon/govern-core/contracts/pipelines/GovernQueue.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8; // TODO: reconsider compiler version before production release\npragma experimental ABIEncoderV2; // required for passing structs in calldata (fairly secure at this point)\n\nimport \"erc3k/contracts/IERC3000.sol\";\n\nimport \"@aragon/govern-contract-utils/contracts/protocol/IArbitrable.sol\";\nimport \"@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol\";\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\nimport \"@aragon/govern-contract-utils/contracts/adaptative-erc165/AdaptativeERC165.sol\";\nimport \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\";\n\nlibrary GovernQueueStateLib {\n    enum State {\n        None,\n        Scheduled,\n        Challenged,\n        Approved,\n        Rejected,\n        Cancelled,\n        Executed\n    }\n\n    struct Item {\n        State state;\n    }\n\n    function checkState(Item storage _item, State _requiredState) internal view {\n        require(_item.state == _requiredState, \"queue: bad state\");\n    }\n\n    function setState(Item storage _item, State _state) internal {\n        _item.state = _state;\n    }\n\n    function checkAndSetState(Item storage _item, State _fromState, State _toState) internal {\n        checkState(_item, _fromState);\n        setState(_item, _toState);\n    }\n}\n\ncontract GovernQueue is IERC3000, AdaptativeERC165, IArbitrable, ACL {\n    // Syntax sugar to enable method-calling syntax on types\n    using ERC3000Data for *;\n    using DepositLib for ERC3000Data.Collateral;\n    using GovernQueueStateLib for GovernQueueStateLib.Item;\n    using SafeERC20 for ERC20;\n\n    // Permanent state\n    bytes32 public configHash; // keccak256 hash of the current ERC3000Data.Config\n    uint256 public nonce; // number of scheduled payloads so far\n    mapping (bytes32 => GovernQueueStateLib.Item) public queue; // container hash -> execution state\n\n    // Temporary state\n    mapping (bytes32 => address) public challengerCache; // container hash -> challenger addr (used after challenging and before resolution implementation)\n    mapping (IArbitrator => mapping (uint256 => bytes32)) public disputeItemCache; // arbitrator addr -> dispute id -> container hash (used between dispute creation and ruling)\n\n    /**\n     * @param _aclRoot account that will be given root permissions on ACL (commonly given to factory)\n     * @param _initialConfig initial configuration parameters\n     */\n    constructor(address _aclRoot, ERC3000Data.Config memory _initialConfig)\n        public\n        ACL(_aclRoot) // note that this contract directly derives from ACL (ACL is local to contract and not global to system in Govern)\n    {\n        initialize(_aclRoot, _initialConfig);\n    }\n\n    function initialize(address _aclRoot, ERC3000Data.Config memory _initialConfig) public initACL(_aclRoot) onlyInit(\"queue\") {\n        _setConfig(_initialConfig);\n        _registerStandard(ARBITRABLE_INTERFACE_ID);\n        _registerStandard(ERC3000_INTERFACE_ID);\n    }\n\n     /**\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window. Pulls collateral from submitter into contract.\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\n       the current configuration of the system\n     */\n    function schedule(ERC3000Data.Container memory _container) // TO FIX: Container is in memory and function has to be public to avoid an unestrutable solidity crash\n        public\n        override\n        auth(this.schedule.selector) // note that all functions in this contract are ACL protected (commonly some of them will be open for any addr to perform)\n        returns (bytes32 containerHash)\n    {   \n        // prevent griefing by front-running (the same container is sent by two different people and one must be challenged)\n        require(_container.payload.nonce == ++nonce, \"queue: bad nonce\");\n        // hash using ERC3000Data.hash(ERC3000Data.Config)\n        bytes32 _configHash = _container.config.hash();\n        // ensure that the hash of the config passed in the container matches the current config (implicit agreement approval by scheduler)\n        require(_configHash == configHash, \"queue: bad config\");\n        // ensure that the time delta to the execution timestamp provided in the payload is at least after the config's execution delay\n        require(_container.payload.executionTime >= block.timestamp + _container.config.executionDelay, \"queue: bad delay\");\n        // ensure that the submitter of the payload is also the sender of this call\n        require(_container.payload.submitter == msg.sender, \"queue: bad submitter\");\n\n        containerHash = ERC3000Data.containerHash(_container.payload.hash(), _configHash);\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.None, // ensure that the state for this container is None\n            GovernQueueStateLib.State.Scheduled // and if so perform a state transition to Scheduled\n        );\n        // we don't need to save any more state about the container in storage\n        // we just authenticate the hash and assign it a state, since all future\n        // actions regarding the container will need to provide it as a witness\n        // all witnesses are logged from this contract at least once, so the \n        // trust assumption should be the same as storing all on-chain (move complexity to clients)\n\n        ERC3000Data.Collateral memory collateral = _container.config.scheduleDeposit;\n        collateral.collectFrom(_container.payload.submitter); // pull collateral from submitter (requires previous approval)\n\n        // TODO: pay court tx fee\n\n        // emit an event to ensure data availability of all state that cannot be otherwise fetched (see how config isn't emitted since an observer should already have it)\n        emit Scheduled(containerHash, _container.payload);\n    }\n\n    /**\n     * @notice Executes an action after its execution delayed has passed and its state hasn't been altered by a challenge or veto\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\n       the current configuration of the system\n     */\n    function execute(ERC3000Data.Container memory _container)\n        public\n        override\n        auth(this.execute.selector) // in most instances this will be open for any addr, but leaving configurable for flexibility\n        returns (bytes32 failureMap, bytes[] memory execResults)\n    {\n        // ensure enough time has passed\n        require(uint64(block.timestamp) >= _container.payload.executionTime, \"queue: wait more\");\n\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Scheduled, // note that we will revert here if the container wasn't previously scheduled\n            GovernQueueStateLib.State.Executed\n        );\n\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter); // release collateral to executor\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    /**\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\n       the current configuration of the system\n     * @param _reason Hint for case reviewers as to why the scheduled container is illegal\n     */\n    function challenge(ERC3000Data.Container memory _container, bytes memory _reason) auth(this.challenge.selector) override public returns (uint256 disputeId) {\n        bytes32 containerHash = _container.hash();\n        challengerCache[containerHash] = msg.sender; // cache challenger address while it is needed\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Scheduled,\n            GovernQueueStateLib.State.Challenged\n        );\n\n        ERC3000Data.Collateral memory collateral = _container.config.challengeDeposit;\n        collateral.collectFrom(msg.sender); // pull challenge collateral from sender\n\n        // create dispute on arbitrator\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\n        (address recipient, ERC20 feeToken, uint256 feeAmount) = arbitrator.getDisputeFees();\n        require(feeToken.safeTransferFrom(msg.sender, address(this), feeAmount), \"queue: bad fee pull\");\n        require(feeToken.safeApprove(recipient, feeAmount), \"queue: bad approve\");\n        disputeId = arbitrator.createDispute(2, abi.encode(_container)); // create dispute sending full container ABI encoded (could prob just send payload to save gas)\n        require(feeToken.safeApprove(recipient, 0), \"queue: bad reset\"); // for security with non-compliant tokens (that fail on non-zero to non-zero approvals)\n\n        // submit both arguments as evidence and close evidence period. no more evidence can be submitted and a settlement can't happen (could happen off-protocol)\n        emit EvidenceSubmitted(arbitrator, disputeId, _container.payload.submitter, _container.payload.proof, true);\n        emit EvidenceSubmitted(arbitrator, disputeId, msg.sender, _reason, true);\n        arbitrator.closeEvidencePeriod(disputeId);\n\n        disputeItemCache[arbitrator][disputeId] = containerHash; // cache a relation between disputeId and containerHash while needed\n\n        emit Challenged(containerHash, msg.sender, _reason, disputeId, collateral);\n    }\n\n    /**\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\n     * @param _container A ERC3000Data.Container struct holding both the paylaod being scheduled for execution and\n       the current configuration of the system\n     * @param _disputeId disputeId in the arbitrator in which the dispute over the container was created\n     */\n    function resolve(ERC3000Data.Container memory _container, uint256 _disputeId) override public returns (bytes32 failureMap, bytes[] memory execResults) {\n        bytes32 containerHash = _container.hash();\n        if (queue[containerHash].state == GovernQueueStateLib.State.Challenged) {\n            // will re-enter in `rule`, `rule` will perform state transition depending on ruling\n            IArbitrator(_container.config.resolver).executeRuling(_disputeId);\n        } // else continue, as we must \n\n        GovernQueueStateLib.State state = queue[containerHash].state;\n\n        emit Resolved(containerHash, msg.sender, state == GovernQueueStateLib.State.Approved);\n\n        if (state == GovernQueueStateLib.State.Approved) {\n            return executeApproved(_container);\n        }\n\n        require(state == GovernQueueStateLib.State.Rejected, \"queue: unresolved\");\n        settleRejection(_container);\n        return (bytes32(0), new bytes[](0));\n    }\n\n    function veto(bytes32 _containerHash, bytes memory _reason) auth(this.veto.selector) override public {\n        queue[_containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Scheduled,\n            GovernQueueStateLib.State.Cancelled\n        );\n\n        emit Vetoed(_containerHash, msg.sender, _reason);\n    }\n\n    /**\n     * @notice Apply a new configuration for all *new* containers to be scheduled\n     * @param _config A ERC3000Data.Config struct holding all the new params that will control the queue\n     */\n    function configure(ERC3000Data.Config memory _config)\n        public\n        override\n        auth(this.configure.selector)\n        returns (bytes32)\n    {\n        return _setConfig(_config);\n    }\n\n    // Finalization functions\n    // In the happy path, they are not externally called (triggered from resolve -> rule -> executeApproved | settleRejection), but left public for security\n\n    function executeApproved(ERC3000Data.Container memory _container) public returns (bytes32 failureMap, bytes[] memory execResults) {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Approved,\n            GovernQueueStateLib.State.Executed\n        );\n\n        // release all collateral to submitter\n        _container.config.scheduleDeposit.releaseTo(_container.payload.submitter);\n        _container.config.challengeDeposit.releaseTo(_container.payload.submitter);\n\n        challengerCache[containerHash] = address(0); // release state, refund gas, no longer needed in state\n\n        return _execute(_container.payload, containerHash);\n    }\n\n    function settleRejection(ERC3000Data.Container memory _container) public {\n        bytes32 containerHash = _container.hash();\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Rejected,\n            GovernQueueStateLib.State.Cancelled\n        );\n\n        address challenger = challengerCache[containerHash];\n\n        // release all collateral to challenger\n        _container.config.scheduleDeposit.releaseTo(challenger);\n        _container.config.challengeDeposit.releaseTo(challenger);\n        challengerCache[containerHash] = address(0); // release state, refund gas, no longer needed in state\n    }\n\n    // Arbitrable\n\n    function rule(uint256 _disputeId, uint256 _ruling) override external {\n        // implicit check that msg.sender was actually arbitrating a dispute over this container\n        IArbitrator arbitrator = IArbitrator(msg.sender);\n        bytes32 containerHash = disputeItemCache[arbitrator][_disputeId];\n        queue[containerHash].checkAndSetState(\n            GovernQueueStateLib.State.Challenged,\n            _ruling == ALLOW_RULING ? GovernQueueStateLib.State.Approved : GovernQueueStateLib.State.Rejected\n        );\n        disputeItemCache[arbitrator][_disputeId] = bytes32(0); // refund gas, no longer needed in state\n\n        emit Ruled(arbitrator, _disputeId, _ruling);\n    }\n\n    function submitEvidence(\n        uint256,\n        bytes calldata,\n        bool\n    ) external override {\n        revert(\"queue: evidence\");\n    }\n\n    // Internal\n\n    function _execute(ERC3000Data.Payload memory _payload, bytes32 _containerHash) internal returns (bytes32, bytes[] memory) {\n        emit Executed(_containerHash, msg.sender);\n        return _payload.executor.exec(_payload.actions, _payload.allowFailuresMap, _containerHash);\n    }\n\n    function _setConfig(ERC3000Data.Config memory _config)\n        internal\n        returns (bytes32)\n    {\n        configHash = _config.hash();\n\n        emit Configured(configHash, msg.sender, _config);\n\n        return configHash;\n    }\n}\n"
    },
    "@aragon/govern-contract-utils/contracts/protocol/IArbitrable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrable.sol\n\npragma solidity ^0.6.8;\n\nimport \"./IArbitrator.sol\";\n\nabstract contract IArbitrable {\n    bytes4 internal constant ARBITRABLE_INTERFACE_ID = bytes4(0x88f3ee69);\n    uint256 internal constant ALLOW_RULING = 4;\n\n    /**\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n    * @param arbitrator IArbitrator instance ruling the dispute\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n    * @param ruling Ruling given by the arbitrator\n    */\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n\n    /**\n    * @dev Emitted when new evidence is submitted for the IArbitrable instance's dispute\n    * @param arbitrator IArbitrator submitting the evidence for\n    * @param disputeId Identification number of the dispute receiving new evidence\n    * @param submitter Address of the account submitting the evidence\n    * @param evidence Data submitted for the evidence of the dispute\n    * @param finished Whether or not the submitter has finished submitting evidence\n    */\n    event EvidenceSubmitted(IArbitrator indexed arbitrator, uint256 indexed disputeId, address indexed submitter, bytes evidence, bool finished);\n\n    /**\n    * @dev Submit evidence for a dispute\n    * @param _disputeId Id of the dispute in the Court\n    * @param _evidence Data submitted for the evidence related to the dispute\n    * @param _finished Whether or not the submitter has finished submitting evidence\n    */\n    function submitEvidence(uint256 _disputeId, bytes calldata _evidence, bool _finished) virtual external;\n\n    /**\n    * @dev Give a ruling for a certain dispute, the account calling it must have rights to rule on the contract\n    * @param _disputeId Identification number of the dispute to be ruled\n    * @param _ruling Ruling given by the arbitrator, where 0 is reserved for \"refused to make a decision\"\n    */\n    function rule(uint256 _disputeId, uint256 _ruling) virtual external;\n}"
    },
    "@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol": {
      "content": "/*\n * SPDX-License-Identifier:    GPL-3.0\n */\n\npragma solidity 0.6.8;\n\nimport \"erc3k/contracts/ERC3000Data.sol\";\n\nimport \"../erc20/SafeERC20.sol\";\n\nlibrary DepositLib {\n    using SafeERC20 for ERC20;\n\n    event Lock(address indexed token, address indexed from, uint256 amount);\n    event Unlock(address indexed token, address indexed to, uint256 amount);\n\n    function collectFrom(ERC3000Data.Collateral memory _collateral, address _from) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            require(token.safeTransferFrom(_from, address(this), _collateral.amount), \"queue: bad get token\");\n\n            emit Lock(_collateral.token, _from, _collateral.amount);\n        }\n    }\n\n    function releaseTo(ERC3000Data.Collateral memory _collateral, address _to) internal {\n        if (_collateral.amount > 0) {\n            ERC20 token = ERC20(_collateral.token);\n            require(token.safeTransfer(_to, _collateral.amount), \"queue: bad send token\");\n\n            emit Unlock(_collateral.token, _to, _collateral.amount);\n        }\n    }\n}"
    },
    "@aragon/govern-contract-utils/contracts/protocol/IArbitrator.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\n// From https://github.com/aragon/aragon-court/blob/master/contracts/arbitration/IArbitrator.sol\n\npragma solidity ^0.6.8;\n\nimport \"../erc20/SafeERC20.sol\";\n\ninterface IArbitrator {\n    /**\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n    * @return Dispute identification number\n    */\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n\n    /**\n    * @dev Close the evidence period of a dispute\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n    */\n    function closeEvidencePeriod(uint256 _disputeId) external;\n\n    /**\n    * @dev Execute the Arbitrable associated to a dispute based on its final ruling\n    * @param _disputeId Identification number of the dispute to be executed\n    */\n    function executeRuling(uint256 _disputeId) external;\n\n    /**\n    * @dev Tell the dispute fees information to create a dispute\n    * @return recipient Address where the corresponding dispute fees must be transferred to\n    * @return feeToken ERC20 token used for the fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n\n    /**\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\n    * @param _subscriber Address of the account paying the subscription fees for\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\n    * @return feeToken ERC20 token used for the subscription fees\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\n    */\n    function getSubscriptionFees(address _subscriber) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}